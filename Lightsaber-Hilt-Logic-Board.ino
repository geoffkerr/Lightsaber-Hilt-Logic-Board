//
// NOTE: burn bootloader first when setting/changing the internal clock frequency
//
//
// LED is on pin 1
// PWMing on pin 1 with analogWrite() is possible, but calls to delay(), micros(), and millis() must be avoided
// as the timer used for those functions is also used for pin 1 PWMs
//
// delay_x() is the same as delay(), but uses the delayMicroseconds() function, which does not use a timer, but
// rather uses processor clock ticks.
//
// delay_x() is probably not as precise as delay(), but it is good enough for our purposes
//

#define LED_PIN 1
#define IGNITE_PIN 2
#define BLADE_DATA_PIN 3

#define SIG_PREAMBLE_DLY      17    // ms
#define SIG_SHORT             1200  // uS
#define SIG_LONG              2400  // uS
#define SIG_ACTIVE            LOW
#define SIG_IDLE              HIGH

#define SIG_COLOR_WHITE       0x00  // these are savi lightsaber/kyber crystal color table colors
#define SIG_COLOR_RED         0x01
#define SIG_COLOR_ORANGE      0x02  // orange color seen in hilt, but unsupported by blade; produces yellow
#define SIG_COLOR_YELLOW      0x03
#define SIG_COLOR_GREEN       0x04
#define SIG_COLOR_TEAL        0x05  // teal color seen in hilt, but unsupported by blade; produces blue
#define SIG_COLOR_BLUE        0x06
#define SIG_COLOR_PURPLE      0x07
#define SIG_COLOR_DARK_PURPLE 0x08  // would expect white; could be an error in code on the blade microcontroller
                                    // 0x09-0x0F repeat this color pattern, no need to include them here

#define SIG_CMD_0             0x00  // ?? seems to do nothing
#define SIG_CMD_0_LEGACY      0x10
#define SIG_CMD_ON            0x20  // ignite, 2nd nibble is color, uses savi saber color table
#define SIG_CMD_ON_LEGACY     0x30  // ignite, 2nd nibble is color, uses legacy saber color table
#define SIG_CMD_OFF           0x40  // ignores color; animates current color to off
#define SIG_CMD_OFF_LEGACY    0x50
#define SIG_CMD_REDFLICKER_1  0x60  // color nibble affects brightness; nearly off to mid brightness
#define SIG_CMD_REDFLICKER_2  0x70  // color nibble affects brightness; mid brightness to full brightness
#define SIG_CMD_4             0x80  // turns blade off; may have another purpose
#define SIG_CMD_4_LEGACY      0x90
#define SIG_CMD_COLOR         0xA0  // color nibble uses savi lightsaber/kyber crystal color table
#define SIG_CMD_COLOR_LEGACY  0xB0  // color nibble uses legacy lightsaber color table
#define SIG_CMD_FLASH         0xC0  // ignores color; animates burst with current color
#define SIG_CMD_FLASH_LEGACY  0xD0  // ignores color; animates burst with current color
#define SIG_CMD_7             0xE0  // turns blade off; may have another purpose
#define SIG_CMD_7_LEGACY      0xF0

unsigned int blade_sig[16];
uint8_t blade_colors[] = { SIG_COLOR_WHITE, SIG_COLOR_RED, SIG_COLOR_YELLOW, SIG_COLOR_GREEN, SIG_COLOR_BLUE, SIG_COLOR_PURPLE, SIG_COLOR_DARK_PURPLE };
uint8_t blade_colors_len = sizeof(blade_colors) / sizeof(blade_colors[0]);
uint8_t blade_color = 0;

// convert a byte value to an array of short/long pairs used transmit 8 bits (1 bit per pair) to the blade
// byte is being sent (based on the order in which this array is constructed) as most significant bit (MSB) first
//
// for each pair:
//    first value (even numbered) will set the data line SIG_IDLE and wait for however many uS is specified by the value
//    second value (odd numbered) will set the data line SIG_ACTIVE and wait for hwoever many uS is specified by the value
//
// bit values: 
//    SHORT IDLE, LONG ACTIVE = 0
//    LONG IDLE, SHORT ACTIVE = 1
//
//    note: interpretation of bit values is subjective. you could reverse the above and, as long as
//          the byte values you transmit match that pattern, it'd work fine.
//          the bit values chosen above are based on aligning the RFID TAG values and their associated 
//          colors to the colors generated by the blade
//
void blade_byte_to_signal(uint8_t val, unsigned int sig[]) {
  for(uint8_t i=0;i<8;i++) {
    if ((val >> 7-i) & 1) {
      sig[(2*i)] = SIG_LONG;
      sig[(2*i)+1] = SIG_SHORT;
    } else {
      sig[(2*i)] = SIG_SHORT;  
      sig[(2*i)+1] = SIG_LONG;
    }
  }
}

// sends a signal to the blade that a command is about to be sent
// this function should ONLY be called from within blade_send_sig()
void blade_send_preamble() {
  digitalWrite(BLADE_DATA_PIN, SIG_ACTIVE);
  delay_x(SIG_PREAMBLE_DLY);
  digitalWrite(BLADE_DATA_PIN, SIG_IDLE);
  delay_x(SIG_PREAMBLE_DLY);
  digitalWrite(BLADE_DATA_PIN, SIG_ACTIVE);
  delay_x(SIG_PREAMBLE_DLY);
  digitalWrite(BLADE_DATA_PIN, SIG_IDLE);
}

// send signal to blade by alternating blade data pin state between high and low
// for periods of time specified in the sig[] array is set by byte_to_signal()
void blade_send_sig(uint8_t cmd) {
  uint8_t i;

  // set blade data pin to OUTPUT mode
  pinMode(BLADE_DATA_PIN, OUTPUT);

  // construct command
  blade_byte_to_signal(cmd, blade_sig);

  // send preamble
  blade_send_preamble();

  // send command
  for(i=0;i<8;i++){
    digitalWrite(BLADE_DATA_PIN, SIG_IDLE);
    delayMicroseconds(blade_sig[(2*i)]);
    digitalWrite(BLADE_DATA_PIN, SIG_ACTIVE);
    delayMicroseconds(blade_sig[(2*i)+1]);
  }
  digitalWrite(BLADE_DATA_PIN, SIG_IDLE);
}

// a set of states that the blade can be in
enum blade_states {
  BLADE_UNPLUGGED,
  BLADE_OFF,
  BLADE_ON
};
enum blade_states blade_state = BLADE_UNPLUGGED;

// a set of variable that control the LED
bool led_on = false;
uint8_t led_level = 0;
int8_t led_level_step = 5;
int16_t led_off_count = 300;  // roughly <num of seconds until auto-shutoff> * 10

// an alternative to delay() which does not utilize the ATTiny85's timer
// this is needed because the LED is on pin 1 and pin 1's PWM timer is also used by delay()
void delay_x(uint16_t delay) {
  for(uint16_t i=0;i<delay;i++) {
    delayMicroseconds(1000);
  }
}

// handle the 'animation' effect of the LED when it's on
void led_handler() {

  // don't do anything if the LED is off
  if (led_on != true) {
    return;
  }

  // after <led_off_count> executions of this function, signal auto-shutoff the LED
  if (led_off_count > 0) {
    led_off_count--;
  }

  // create a breathing effect by changing the direction of step
  if ( uint8_t(led_level + led_level_step) > 127) {
    led_level_step *= -1;

    // if we've just finished fading out and are about to fade in, but led_off_count is at zero, 
    // disable the LED
    if (led_level_step > 0 && led_off_count < 1) {
      enable_led(false);
      return;
    }
  }
  led_level = led_level + led_level_step;

  analogWrite(LED_PIN, led_level);
}

// enable or disable the LED depending on boolean value passed to function
void enable_led(bool state) {
  if (state == true && led_on == false) {
    led_level = 0;
    led_level_step = 3;
    led_off_count = 300;
    led_on = true;
  } else if (state == false && led_on == true) {
    digitalWrite(LED_PIN, LOW);
    led_on = false;
  }
}

// determine if switch is on or off
bool switch_is_on() {
  if (digitalRead(IGNITE_PIN) == HIGH) {
    return true;
  }
  return false;
}

// determine if blade is present
bool blade_is_present() {
  pinMode(BLADE_DATA_PIN, INPUT);
  if (digitalRead(BLADE_DATA_PIN) == HIGH) {
    return true;
  } else {
    return false;
  }
}

// executes when the MCU first receives power.
// this will happen when a crystal is being inserted
void power_on_sequence() {
  for(uint8_t i=0;i<5;i++) {
    analogWrite(LED_PIN, 127);
    delay_x(100);
    digitalWrite(LED_PIN, LOW);
    delay_x(100);
  }
}

// are you ready?
void setup() {

  // the "on" switch is the switch normally used to detect that a crystal has been inserted.
  // there will be people who fidget with it and have trouble getting the silly thing in
  // this delay allows for a few false power-ups before starting
  delay_x(2000);

  pinMode(LED_PIN, OUTPUT);
  pinMode(IGNITE_PIN, INPUT);
  blade_state = BLADE_UNPLUGGED;
  power_on_sequence();
}

// merry-go-round
void loop() {

  // get state of saber
  bool blade_plugged_in = blade_is_present();
  bool switch_on = switch_is_on();
  
  // state machine
  switch (blade_state) {

    // blade is currently not present
    case BLADE_UNPLUGGED:

      // blade has been plugged in
      if (blade_plugged_in) {
        blade_state = BLADE_OFF;
        enable_led(true);

      // a friendly reminder that the blade is not plugged in
      } else if (switch_on) {
        power_on_sequence();
        delay_x(500);
      }
      break;

    // blade is present, but currently off
    case BLADE_OFF:

      // blade has been unplugged
      if (!blade_plugged_in) {
        blade_state = BLADE_UNPLUGGED;
        enable_led(false);

      // blade has been switched on
      } else if (switch_on) {
        enable_led(false);

        // send signal to ignite the blade
        blade_send_sig( SIG_CMD_ON | blade_colors[blade_color] );
        delay_x(1000);

        blade_state = BLADE_ON;
      }
      break;

    // blade is on
    case BLADE_ON:

      // blade has been unplugged, turn everything off
      if (!blade_plugged_in) {
        blade_state = BLADE_UNPLUGGED;
        enable_led(false);

      // blade has been switched off
      } else if (!switch_on) {

        // send the turn off signal
        blade_send_sig(SIG_CMD_OFF);
        delay_x(1000);
        enable_led(true);

        // set the blade color for the next time it turns on
        if (++blade_color >= blade_colors_len) {
          blade_color = 0;
        }

        blade_state = BLADE_OFF;

      // blade is still on, so keep sending it the appropriate color signal
      } else {
        blade_send_sig( SIG_CMD_COLOR | blade_colors[blade_color] );
        delay_x(100);
      }
      break;
  }

  led_handler();
  delay_x(100);
}
// broken down